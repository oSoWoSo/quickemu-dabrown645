#!/usr/bin/bash
export LC_ALL="C"

function main() {
    trap cleanup EXIT

    if ((BASH_VERSINFO[0] < 4)); then
        echo "Sorry, you need bash 4.0 or newer to run this script"
        exit 1
    fi

    PARAMS=""
    BASE_DIR="$(dirname "${BASEDIR_SOURCE}")"
    if [[ "${BASE_DIR}" == '.' ]]; then
        PLUGINS="${BASE_DIR}/quickget_plugins"          # < used in development
    else
        PLUGINS="/usr/share/quickemu/quickget_plugins"  # < used for production
    fi
    TMPDIR="${HOME}/quickget-tmp"   # to be used for temp files if needed
    mkdir -p "${TMPDIR}"
                                    # will automatically get deleted

    # Set defaults for arguments
    declare -A DISTRO_INFO # This get set in get_distro_info then made read only
    TEST_ISO_URL=false
    SHOW_ISO_URL=false
    OPEN_DISTRO_HOME_PAGE=false
    USE_COLOR=auto
    COLORS_SET=false

    set_colors

    while (( "${#}" )); do
        case "${1}" in
            list|list_csv)
                list_csv
                exit 0
                ;;
            list_json)
                list_json
                exit 0
                ;;
            --version|-version)
                "${BASE_DIR}"/quickemu ---version
                exit 0
                ;;
            --test-iso-url|-t)
                TEST_ISO_URL=true
                shift
                ;;
            --show-iso-url|-s)
                SHOW_ISO_URL=true
                shift
                ;;
            --open-distro-homepage|-o)
                OPEN_DISTRO_HOME_PAGE=true
                shift
                ;;
            --color)
                USE_COLOR="${2}"
                shift 2
                case "${USE_COLOR}" in
                    on|off|auto) : ;;
                    *)
                        error "valid values are [on|off|auto]"
                        ;;
                esac
                ;;
            --*|-*) # unsupported flags
                error "Unsupported flag ${1}"
                shift
                usage
                ;;
            *) # Preserve positional arguments
                PARAMS="${PARAMS} ${1}"
                shift
                ;;
        esac
    done

    readonly TEST_ISO_URL SHOW_ISO_URL OPEN_DISTRO_HOME_PAGE USE_COLOR

    # set positional arguments in their proper place
    eval set -- "${PARAMS}"

    [ -z "${1}" ] && OS="" || OS="${1,,}"
    [ -z "${2}" ] && RELEASE="" || RELEASE="${2,,}"
    [ -z "${3}" ] && EDITION="" || EDITION="${3,,}"

    readonly OS RELEASE EDITION

    if [ -z "${OS}" ]; then
        error "You must supply a distribution and release at a minimum"
        printf "Valid OS's:\n"
        supported_oses
        printf "\n"
        usage
    elif ! valid_os "${OS}"; then
        error "${OS} is not a valid OS please resubmit with valid OS"
        printf "Valid OS's:\n"
        supported_oses
        printf "\n"
        usage
    else            # shellcheck disable=SC1090
        source "${PLUGINS}/${OS}".plug          # get OS specific version of functions

        if ${OPEN_DISTRO_HOME_PAGE}; then
            open_url "$(homepage)"
            exit 0
        fi

        declare -r -A EDITIONS="($(editions))"

        if [ -z "${RELEASE}" ]; then
            error "You must specify a release and an edition for $(pretty_name):"
            if editions_required; then
                release_editions
            else
                printf "%-15s |" "Releases"
                for item in $(releases); do
                    printf " %s" "${item}"
                done
                printf "\n"
            fi
            usage
        else
            if release_valid; then
                if editions_required; then
                    if [ -z "${EDITION}" ];then
                        error "You must specify one of the valid release edition combinations for $(pretty_name)"
                        release_editions
                        usage
                    else
                        if edition_valid; then
                            VM_PATH="${OS}-${RELEASE}-${EDITION}"
                        else
                            error "You must specify one of the valid release edition combinations for ${OS}"
                            release_editions
                            usage
                        fi
                    fi
                    if edition_valid; then
                        VM_PATH="${OS}-${RELEASE}-${EDITION}"
                    else
                        error "You must specify one of the valid release edition combinations for $(pretty_name)"
                        release_editions
                        usage
                    fi
                else
                    if [ -n "${EDITION}" ]; then
                        error "Edition is not aloud you must specify only a valid release ${OS}"
                        release_editions
                        usage
                    else
                        VM_PATH="${OS}-${RELEASE}"
                    fi
                fi
            else
                error "You must specify one of the valid release edition combinations for $(pretty_name)"
                if editions_required; then
                    release_editions
                else
                    printf "%-15s |" "Releases"
                    for item in $(releases); do
                        printf " %s" "${item}"
                    done
                    printf "\n"
                    fi
                usage
            fi
        fi
    fi

    declare -A DISTRO_INFO="($(get_distro_info "${EDITION}"))"
    #readonly DISTRO_INFO        # DISTRO_INFO has now been set lock it up
    for key in "${!DISTRO_INFO[@]}"; do
        printf "%-5s: %s\n" "${key}" "${DISTRO_INFO["${key}"]}"
    done | sort

    if ${SHOW_ISO_URL}; then
        show_iso_url
        exit 0
    elif ${TEST_ISO_URL}; then
        test_iso_url
        exit 0
    else
        :
    fi

    create_vm

}

#
# Functions used by main
#

function cleanup() {
    if [ -n "$(jobs -p)" ]; then
        kill "$(jobs -p)"
    fi
    rm -rf "${TMPDIR}"
}

function check_hash() {
    case "${#DISTRO_INFO['hash']}" in
        32) hash_algo=md5sum;;
        40) hash_algo=sha1sum;;
        64) hash_algo=sha256sum;;
        128) hash_algo=sha512sum;;
        None)
            warning "Hash not provided , not checking ${OS} hash"
            return 0
            ;;
        *)
            warning "Can't guess hash algorithm, not checking ${OS} hash"
            return 0
            ;;
    esac

    printf "Checking %s with %s... " "${DISTRO_INFO['iso']}" "${hash_algo}"

    if ! echo "${DISTRO_INFO['hash']} ${VM_PATH}/${DISTRO_INFO['iso']##*/}" | ${hash_algo} --check --status; then
        error "${DISTRO_INFO['iso']} doesn't match ${DISTRO_INFO['hash']}"
    else
        printf " %sGood%s\n" "${fgreen}" "${reset}"
    fi
}

function create_vm() {
    if [ -d "${VM_PATH}" ]; then
        error "%s already exists exiting:\n" ${VM_PATH}
        usage
    else
        mkdir -p "${VM_PATH}"
    fi

    get_file "${DISTRO_INFO['url']}/${DISTRO_INFO['iso']}" "${VM_PATH}"

    check_hash "${DISTRO_INFO['url']}"/"${DISTRO_INFO['iso']}" "${DISTRO_INFO['so
    hash']}"

    make_vm_config "${DISTRO_INFO['iso']}"
}

function default_vm_config() {
    {
        printf "#!%s --vm\n" "$(which quickemu)"
        printf "guest_os=\"%s\"\n" "linux"
        printf "disk_img=\"%s/disk.qcow2\"\n" ${VM_PATH}
        printf "iso=\"%s\"\n" "${VM_PATH}/${DISTRO_INFO['iso']##*/}"
        printf "disk_size=\"32G\"\n"
    } > "${VM_PATH}.conf"

    printf "\nTo start your %s virtual machine run:\n" pretty_name
    printf "\tquickemu --vm %s\n\n" "${VM_PATH}.conf"
}

function warning() {
    if ! ${COLORS_SET}; then
        COLORS_SET=true
    fi

    printf "%sWARNING: %s%s\n" "${fyellow}" "${reset}" "${*}"
}

function error() {
    if ! ${COLORS_SET}; then
        COLORS_SET=true
    fi

    printf "%sERROR: %s%s\n" "${fred}" "${reset}" "${*}"
}

function edition_valid() {
    #   This function validates that the supplied edition is one of the
    #   valid releases
    [[ "${EDITIONS["${RELEASE}"]}" == *"${EDITION}"* ]] && return 0 || return 1
}

function release_valid() {
    #   This function validates that the supplied release is one of the
    #   valid releases
    #
    for value in $(releases); do
        [[ "${RELEASE}" == "${value,,}" ]] && return 0
    done

    return 1
}

function get_file() {
    local url=${1}
    local dir=${2}
    local file=${3}

    if [ -z "${file}" ]; then
        file="${url##*/}"
    fi

    if command -v aria2c &>/dev/null; then
        echo aria2c
        if ! aria2c --stderr -x16 --continue=true --summary-interval=0 --download-result=hide --console-log-level=error "${url}" --dir "${dir}" -o "${file}"; then
          echo #Necessary as aria2c in suppressed mode does not have new lines
          error "Failed to download ${URL} with aria2c. Try running 'quickget' again."
          exit 1
        fi
        echo #Necessary as aria2c in suppressed mode does not have new lines
    elif ! wget --quiet --continue --tries=3 --read-timeout=10 --show-progress --progress=bar:force:noscroll "${url}" -O "${dir}/${file}"; then
        error "Failed to download ${URL} with wget. Try running 'quickget' again."
        exit 1
    fi
}

function list_csv() {
    # TODO
    echo list_csv
}

function list_json {
    # TODO
    list_csv
    echo list_json
}

function open_url() {
    local url=${1}
    xdg-open "${url}" || sensible-browser "${url}" || x-www-browser "${url}" || gnome-open "${url}";
}

function release_editions(){
    printf "%-15s | %s\n" "Releases" "Editions"
    for key in "${!EDITIONS[@]}"; do
        printf "%-15s | %s\n" "${key}" "$(echo "${EDITIONS["${key}"]}" | tr "!" " ")"
    done | sort
}

function set_colors() {
    if [[ $(tput colors) -ge 8 ]]; then
#    if tput setaf 1 &> /dev/null; then      # Are colors supported
        tput sgr0
        if [[ "${USE_COLOR}" == "auto" ]]; then
            if [[ -t 1 ]] && [[ -t 2 ]]; then
                USE_COLOR="on"
            else
                USE_COLOR="off"
            fi
        fi
    else
        USE_COLOR="off"                     # color not supported
    fi

    # shellcheck disable=SC2034
    if [[ "${USE_COLOR}" == "on" ]]; then
        bold=$(tput bold)       ; dim=$(tput dim)
        smul=$(tput smul)       ; rmul=$(tput rmul)
        smso=$(tput smso)       ; rmso=$(tput rmso)
        rev=$(tput rev)         ; blink=$(tput blink)
        invis=$(tput invis)     ; reset=$(tput sgr0)

        fblack=$(tput setaf 0)  ; bblack=$(tput setab 0)
        fred=$(tput setaf 1)    ; bred=$(tput setab 1)
        fgreen=$(tput setaf 2)  ; bgreen=$(tput setab 2)
        fyellow=$(tput setaf 3) ; byellow=$(tput setab 3)
        fblue=$(tput setaf 4)   ; bblue=$(tput setab 4)
        fpurple=$(tput setaf 5) ; bpurple=$(tput setab 5)
        fcyan=$(tput setaf 6)   ; bcyan=$(tput setab 6)
        fwhite=$(tput setaf 7)  ; bwhite=$(tput setab 7)
    else
        bold=                   ; dim=
        smul=""                 ; rmul=""
        smso=""                 ; rmso=""
        rev=""                  ; blink=""
        invis=""                ; reset=""

        fblack=""               ; bblack=""
        fred=""                 ; bred=""
        fgreen=""               ; bgreen=""
        fyellow=""              ; byellow=""
        fblue=""                ; bblue=""
        fpurple=""              ; bpurple=""
        fcyan=""                ; bcyan=""
        fwhite=""               ; bwhite=""
    fi
}

function show_iso_url() {
    echo "${DISTRO_INFO['url']}/${DISTRO_INFO['iso']}"
}

function supported_oses() {
    (
        cd "${PLUGINS}" || ( echo "${PLUGINS} not found"; exit )
        command ls ./*.plug* \
            | sed -e 's/*\///' -e 's/\.plug//' \
                -e 's/\.\///' \
            |   column -x
    )
    return 0
}

function test_iso_url() {
    wget --spider "$(show_iso_url)"
}

function usage() {
    printf "USAGE:\n"
    exit 1
}

function valid_os() {
    local os=${1}
    # shellcheck disable=SC1090
    if [ -e "${PLUGINS}/${os}.plug" ]; then
        source  "${PLUGINS}/${os}.plug"
        return 0
    else
        return 1
    fi
}

main "${@}"
